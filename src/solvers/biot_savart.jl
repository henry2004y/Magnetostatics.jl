"""
    BiotSavart <: AbstractSolver

Solver that uses the Biot-Savart law to compute the magnetic field.
"""
struct BiotSavart <: AbstractSolver end

"""
    solve(solver::BiotSavart, source::Wire, r::SVector{3, T}) where T

Compute the magnetic field at position `r` generated by a `Wire` source using the Biot-Savart law.
It assumes the wire is composed of straight segments between the points.
"""
function solve(::BiotSavart, source::Wire{T}, r::SVector{3, T}) where {T}
    B = @SVector zeros(T, 3)
    points = source.points
    I = source.current

    for i in 1:(length(points) - 1)
        r1 = points[i]
        r2 = points[i + 1]

        # Vector from r to the start and end of the segment
        a = r - r1
        b = r - r2
        c = r2 - r1 # Segment vector

        # Cross product (a x c is equivalent to I dl x r)
        # However, a more robust form for straight segment is:
        # B = (mu0 I / 4pi) * (c x a) / |c x a|^2 * ( (c.a)/|a| - (c.b)/|b| )
        # Let's use the standard discretized integral form for simplicity first,
        # or the exact segment formula. Exact formula is better for numerical stability near wire.

        # Using exact formula for straight segment:
        # B = \frac{\mu_0 I}{4 \pi} \frac{\mathbf{dl} \times \mathbf{r}}{|\mathbf{dl} \times \mathbf{r}|^2} \left( \frac{\mathbf{dl} \cdot \mathbf{r}}{r} - \frac{\mathbf{dl} \cdot (\mathbf{r}-\mathbf{dl})}{|\mathbf{r}-\mathbf{dl}|} \right)
        # where r is vector from start of segment to observation point.

        dl = c
        R = r - r1 # Vector from start of segment to observation point

        cross_prod = cross(dl, R)
        cross_sq = dot(cross_prod, cross_prod)

        if cross_sq < 1.0e-20 # Check for singularity (point on line)
            continue
        end

        # Geometric factors
        # Projection of R onto the direction of dl
        # cos(theta1) = (dl . R) / (|dl| |R|)
        # cos(theta2) = (dl . (R - dl)) / (|dl| |R-dl|)

        # Let's stick to a robust implementation
        # normalized cross product direction
        u_n = cross_prod / sqrt(cross_sq)

        # Perpendicular distance rho = |cross(dl, R)| / |dl|
        L = norm(dl)
        rho = sqrt(cross_sq) / L

        # Angles
        # cos_theta1 = dot(dl, a) / (L * norm(a))
        # cos_theta2 = dot(dl, b) / (L * norm(b))

        # Wait, let's use the vector form directly
        # B = (mu0 I / 4pi) * (cross(dl, R) / |cross(dl, R)|^2) * (dot(dl, a)/|a| - dot(dl, b)/|b|)

        term = (dot(dl, a) / norm(a) - dot(dl, b) / norm(b))
        B += (μ0_4π * I) * (cross_prod / cross_sq) * term
    end

    return B
end

# Helper to support arbitrary vector input
function solve(solver::BiotSavart, source::AbstractCurrentSource, r::AbstractVector)
    return solve(solver, source, SVector{3}(r))
end
