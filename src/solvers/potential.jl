"""
    VectorPotential <: AbstractSolver

Solver that computes the magnetic vector potential `A`.
"""
struct VectorPotential <: AbstractSolver end

"""
    solve(solver::VectorPotential, source::Wire, r) where T

Compute the vector potential A at position `r` generated by a `Wire` source.
Integral of (mu0 I / 4pi) * dl / |r - r'|.
"""
function solve(::VectorPotential, source::Wire{T}, r::SVector{3, T}) where {T}
    A = @SVector zeros(T, 3)
    points = source.points
    I = source.current

    for i in 1:(length(points) - 1)
        r1 = points[i]
        r2 = points[i + 1]

        # Segment vector
        l = r2 - r1
        L = norm(l)
        L < 1.0e-20 && continue
        u = l / L # Unit vector along wire

        # Simpler form using r1 and r2 distances:
        d1 = norm(r - r1)
        d2 = norm(r - r2)

        # The integral of 1/|r-r'| along the segment is:
        # ln( (d1 + d2 + L) / (d1 + d2 - L) )

        val = log((d1 + d2 + L) / (d1 + d2 - L))

        A += (μ0_4π * I * val) * u
    end

    return A
end

"""
    solve(solver::VectorPotential, source::Dipole, r) where T

Compute vector potential A for a magnetic dipole.
A = (mu0 / 4pi) * (m x r) / r^3
"""
function solve(::VectorPotential, source::Dipole{T}, r::SVector{3, T}) where {T}
    r_mag = norm(r)
    if r_mag < 1.0e-10
        return @SVector zeros(T, 3)
    else
        return (μ0_4π / r_mag^3) * cross(source.M, r)
    end
end

"""
    solve(solver::VectorPotential, source::CurrentLoop, r::AbstractVector)

Compute vector potential A for a circular current loop.
"""
function solve(::VectorPotential, loop::CurrentLoop{T}, r::SVector{3, T}) where {T}
    # Using the same coordinate transformation as in getB_loop
    (; radius, current, center, normal) = loop
    n_hat = normal

    # Relative position
    r_rel = r - center

    # Local coordinates
    z_local = dot(r_rel, n_hat)
    rho_vec = r_rel - z_local * n_hat
    rho = norm(rho_vec)

    if rho < 1.0e-10 # On-axis
        # A is zero on axis for a loop due to symmetry
        return @SVector zeros(T, 3)
    end

    # A_phi calculation using Elliptic integrals
    # A_phi = (mu0 I / pi k) * sqrt(R/rho) * [ (1 - k^2/2)*K - E ]
    # where k^2 = 4 R rho / ((R+rho)^2 + z^2)

    R = radius
    denom_sq = (R + rho)^2 + z_local^2
    k_sq = 4 * R * rho / denom_sq
    k = sqrt(k_sq)

    K_val = ellipk(k_sq)
    E_val = ellipe(k_sq)

    prefactor = (μ₀ * current) / (π * k) * sqrt(R / rho)

    A_phi = prefactor * ((1 - k_sq / 2) * K_val - E_val)

    # Transform A_phi * phi_hat back to Cartesian
    # phi_hat = (-sin phi, cos phi, 0) in local basis where x_local is along rho_vec
    # Actually, rho_vec defines the radial direction. phi_vec is n_hat x rho_hat

    rho_hat = rho_vec / rho
    phi_hat = cross(n_hat, rho_hat)

    return A_phi * phi_hat
end

# Helpers to support arbitrary location input
function solve(solver::VectorPotential, source::Wire{T}, r) where {T}
    return solve(solver, source, SVector{3, T}(r))
end
function solve(solver::VectorPotential, source::Dipole{T}, r) where {T}
    return solve(solver, source, SVector{3, T}(r))
end
function solve(solver::VectorPotential, source::CurrentLoop{T}, r) where {T}
    return solve(solver, source, SVector{3, T}(r))
end

# Make struct callable
function (solver::VectorPotential)(source, r)
    return solve(solver, source, r)
end
