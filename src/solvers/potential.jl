"""
    VectorPotential <: AbstractSolver

Solver that computes the magnetic vector potential `A`.
"""
struct VectorPotential <: AbstractSolver end

"""
    solve(solver::VectorPotential, source::Wire, r::SVector{3, T}) where T

Compute the vector potential A at position `r` generated by a `Wire` source.
Integral of (mu0 I / 4pi) * dl / |r - r'|.
"""
function solve(solver::VectorPotential, source::Wire{T}, r::SVector{3, T}) where {T}
    A = @SVector zeros(T, 3)
    points = source.points
    I = source.current
    μ0_4π = 1.0e-7

    for i in 1:(length(points) - 1)
        r1 = points[i]
        r2 = points[i + 1]

        # Segment vector
        l = r2 - r1
        L = norm(l)
        if L < 1.0e-20
            continue
        end
        u = l / L # Unit vector along wire

        # Vector from start of segment to observation point
        R1 = r - r1

        # Projection of R1 onto wire direction
        z_proj = dot(R1, u)

        # Perpendicular distance squared
        rho_sq = norm(R1)^2 - z_proj^2

        # Limits of integration along wire: 0 to L
        # Integral of 1/sqrt(rho^2 + (z - z')^2) dz'
        # = [-ln( (z-z') + sqrt(rho^2 + (z-z')^2) )] from 0 to L
        # Let s = z - z', ds = -dz'
        # ...
        # Result is ln( (z_proj + sqrt(rho^2 + z_proj^2)) / (z_proj - L + sqrt(rho^2 + (z_proj - L)^2)) )

        # Simpler form using r1 and r2 distances:
        d1 = norm(r - r1)
        d2 = norm(r - r2)

        # The integral of 1/|r-r'| along the segment is:
        # ln( (d1 + d2 + L) / (d1 + d2 - L) )

        val = log((d1 + d2 + L) / (d1 + d2 - L))

        A += (μ0_4π * I * val) * u
    end

    return A
end

"""
    solve(solver::VectorPotential, source::Dipole, r::SVector{3, T}) where T

Compute vector potential A for a magnetic dipole.
A = (mu0 / 4pi) * (m x r) / r^3
"""
function solve(solver::VectorPotential, source::Dipole{T}, r::SVector{3, T}) where {T}
    r_mag = norm(r)
    if r_mag < 1.0e-10
        return @SVector zeros(T, 3)
    end

    μ0_4π = 1.0e-7

    return (μ0_4π / r_mag^3) * cross(source.M, r)
end

"""
    solve(solver::VectorPotential, source::CurrentLoop, r::AbstractVector)

Compute vector potential A for a circular current loop.
"""
function solve(solver::VectorPotential, loop::CurrentLoop{T}, r::AbstractVector) where {T}
    # Using the same coordinate transformation as in getB_loop
    (; radius, current, center, normal) = loop
    n_hat = normal

    # Relative position
    r_rel = r - center

    # Local coordinates
    z_local = dot(r_rel, n_hat)
    rho_vec = r_rel - z_local * n_hat
    rho = norm(rho_vec)

    if rho < 1.0e-10 # On-axis
        # A is zero on axis for a loop due to symmetry
        return @SVector zeros(T, 3)
    end

    # A_phi calculation using Elliptic integrals
    # A_phi = (mu0 I / pi k) * sqrt(R/rho) * [ (1 - k^2/2)*K - E ]
    # where k^2 = 4 R rho / ((R+rho)^2 + z^2)

    R = radius
    denom_sq = (R + rho)^2 + z_local^2
    k_sq = 4 * R * rho / denom_sq
    k = sqrt(k_sq)

    K_val = ellipk(k_sq)
    E_val = ellipe(k_sq)

    μ0 = 4π * 1.0e-7
    prefactor = (μ0 * current) / (π * k) * sqrt(R / rho)

    A_phi = prefactor * ((1 - k_sq / 2) * K_val - E_val)

    # Transform A_phi * phi_hat back to Cartesian
    # phi_hat = (-sin phi, cos phi, 0) in local basis where x_local is along rho_vec
    # Actually, rho_vec defines the radial direction. phi_vec is n_hat x rho_hat

    rho_hat = rho_vec / rho
    phi_hat = cross(n_hat, rho_hat)

    return A_phi * phi_hat
end

# Make struct callable
function (solver::VectorPotential)(source::AbstractCurrentSource, r)
    return solve(solver, source, r)
end
